<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>settimeout定时器精度</title>
    <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,minimal-ui">
    <script src="js/tpler.js"></script>
</head>

<body>
    因为js单线程原因,如果遇到繁忙,定时器肯定不准,而且肯定是越来越长的,用webwork多线程解决 还有一个精度问题就是最小间隔setTimeout(fun,0) 在js线程不忙的时候,也不可能0秒后马上执行,总有个最小间隔,每个浏览器还各不一样,这个未做测试 我看一篇文章中说的是w3c的标准,定时器的最小时间执行是4ms
    <script>
    var time1 = +new Date();
    var time2;
    console.log(time1)
    setTimeout(function() {
        time2 = +new Date()
        console.log(time2);
        console.log("最小间隔:" + (time2 - time1) + "ms"); //结果有时是3  有时是4
    }, 0);


    //优化 减少频繁操作
    // 1.比如如果绑定window.onresize,在浏览器缩放的时候,该触发的非常频繁,所以可以延迟执行,当下次执行到的时候clear掉,减少频繁执行
    //延迟操作
    var timer;
    _.setTimeout = function(fn, t) {

        (function() {
            timer && clearTimeout(timer); //150ms内的操作 clear
            timer = setTimeout(function() {
                fn && fn()
            }, t || 150);
        })();
    }


    var draw = _.draw().ratio("1:1").background({ color: "#ccc" });
    document.body.appendChild(draw.canvas);

    var offsetPos = _.pos(draw.canvas)

    var realte = function(p, offset) {

        return _.extend({}, p, {
            x: p.x - offset.x,
            y: p.y - offset.y
        })
        // return 


    }

    var vs = []
    toucher([{
        el: document,
        type: "touchstart",
        callback: function() {
            time1 = +new Date();
            console.log(time1)
            vs = [];

        }

    }, {
        el: document,
        type: "touchmove",
        callback: function(item, ev) {
            var pos = _.pos(ev,offsetPos)
            //相对位置

            vs.push(pos)

            // _.setTimeout(function() {
            //     // console.log(pos)
            //     vs.push(pos)
            // })
        }
    }, {
        el: document,
        type: "touchend",
        callback: function() {

            time2 = +new Date()
            console.log(time2);
            console.log("touch间隔:" + (time2 - time1) + "ms");
            console.log(vs)

            draw.link(vs)


        }

    }])
    </script>
</body>

</html>